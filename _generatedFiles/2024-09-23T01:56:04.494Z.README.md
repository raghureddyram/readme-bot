Based on the provided information and the change summary, I'll create a new README.md file that incorporates the existing content and includes additional details about the project setup, running instructions, and architectural decisions. Here's the updated README.md:


# Vision Extract

Vision Extract is a Django-based project that leverages OpenAI's GPT-4 to parse images of PDFs and extract financial data from statements.

## Prerequisites

- Python 3.10 or higher
- Poetry (for dependency management)
- OpenAI API key

## Setup

1. Clone the repository:
   
   git clone <repository-url>
   cd vision-extract
   

2. Install dependencies using Poetry:
   
   poetry install
   

3. Set up environment variables:
   Create a `.env` file in the project root and add your OpenAI API key:
   
   OPENAI_KEY=your_api_key_here
   

## How to Run

1. Apply database migrations:
   
   poetry run python vision/manage.py migrate
   

2. Start the Django development server:
   
   poetry run python vision/manage.py runserver
   

3. Access the application at `http://localhost:8000`

## Available Endpoints

- `/pdf_viewer/{pdf_name}`: Renders the specified PDF in a webpage.
  Example: `http://localhost:8000/pdf_viewer/sample`
- `/pdf_viewer/process`: Processes all PDFs in the `source_pdfs` directory and converts relevant pages to images.
  Example: `http://localhost:8000/pdf_viewer/process`
- `/extractions/sample`: Provides JSON output of the extractions from the sample PDF.
  Example: `http://localhost:8000/extractions/sample`

## How to Test

Run the tests using pytest:


poetry run pytest


## Architecture

The project is structured as a Django application with two main components:

1. `pdf_viewer`: Handles PDF rendering and processing.
2. `extractions`: Manages the extraction of financial data from PDFs.

Key architectural choices:

- Uses OpenAI's GPT-4 for intelligent parsing of PDF contents.
- Implements a page-by-page summarization technique to extract relevant information.
- Utilizes Pydantic for structured data modeling and validation.
- Employs Django's built-in admin interface for easy management.

## Extraction Technique

1. The process starts by summarizing the contents of each page range in the PDF.
2. If the contents are relevant (related to account holder, account value, or holdings), the summary is captured as part of the conversation history.
3. After processing all pages, the extracted information is converted into JSON.
4. Pydantic is used to form a structured response from the JSON output.
5. Targeted prompts are created for holdings and account summaries.

## Sample Data Models

While the current implementation uses Pydantic models for data validation, here are potential Django models that could be used:

python
from django.db import models

class FinancialStatement(models.Model):
    account_number = models.CharField(max_length=50)
    account_holder = models.CharField(max_length=100)
    portfolio_value = models.DecimalField(max_digits=15, decimal_places=2)

class Holding(models.Model):
    statement = models.ForeignKey(FinancialStatement, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    cost_basis = models.DecimalField(max_digits=15, decimal_places=2)


## Possible Enhancements

1. Implement user authentication and authorization for secure access to financial data.
2. Add support for multiple PDF formats and sources.
3. Improve error handling and logging for better debugging and monitoring.
4. Implement a caching mechanism to improve performance for frequently accessed data.
5. Create a user-friendly interface for uploading and managing PDFs.
6. Integrate with external financial APIs for real-time data validation and enrichment.
7. Implement a queuing system for processing large numbers of PDFs asynchronously.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the [MIT License](LICENSE).


This README.md file provides a comprehensive overview of the Vision Extract project, including setup instructions, running guidelines, architectural decisions, and potential enhancements. It incorporates the existing content from the old README and adds more detailed information about the project structure and functionality.